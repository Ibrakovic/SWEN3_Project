package org.openapitools.service.impl;

import java.io.IOException;
import java.io.InputStream;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.openapitools.constant.Constants;
import org.openapitools.dto.DocumentDTO;
import org.openapitools.entity.Document;
import org.openapitools.exception.InvalidDocumentException;
import org.openapitools.exception.MinioConnectionException;
import org.openapitools.exception.RabbitMQConnectionException;
import org.openapitools.model.DocumentInfo;
import org.openapitools.model.ResultInfo;
import org.openapitools.repository.DocumentRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;

import com.fasterxml.jackson.core.exc.StreamReadException;
import com.fasterxml.jackson.databind.DatabindException;
import com.fasterxml.jackson.databind.ObjectMapper;

import software.amazon.awssdk.services.s3.S3Client;
import software.amazon.awssdk.services.s3.model.PutObjectRequest;
import software.amazon.awssdk.services.s3.model.S3Exception;

@Service
public class DocumentServiceImpl {

	private static final Logger logger = LoggerFactory.getLogger(DocumentServiceImpl.class);

	@Autowired
	private DocumentRepository documentRepository;

	@Autowired
	private AmqpTemplate rabbitTemplate;

	@Autowired
	private S3Client s3Client;

	@Value(value = "${spring.rabbitmq.queue.documentQueue}")
	String documentQueue;

	@Value(value = "${spring.rabbitmq.queue.resultQueue}")
	String resultQueue;

	@Value(value = "${spring.minio.bucket.name}")
	String bucketName;

	/**
	 * Stores the metadata of the uploaded file (file name, file size, upload date)
	 * in the database. The file name is generated by appending a timestamp to the
	 * original file name. The file metadata is saved in the `documentRepository`.
	 * 
	 * @param file the file being uploaded
	 * @return the Document object containing file metadata after saving it to the
	 *         database
	 * @throws InvalidDocumentException if any exception occurs while storing the
	 *                                  metadata
	 */
	public Document storeMetadata(MultipartFile file) {
		try {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(Constants.DATE_TIME_PATTERN);
			String timestamp = LocalDateTime.now().format(formatter);
			String filename = timestamp.concat("_").concat(file.getOriginalFilename());

			Document document = new Document();
			document.setFileName(filename);
			document.setFileSize(file.getSize());
			document.setUploadDate(LocalDateTime.now());
			return documentRepository.save(document);
		} catch (Exception e) {
			logger.error("Exception occurred while storing metadata : {}", e.getMessage());
			throw new InvalidDocumentException("\"Exception occurred while storing metadata : " + e.getMessage());
		}
	}

	/**
	 * Sends the file metadata (bucket name and file name) to RabbitMQ for further
	 * processing. The file metadata is packaged into a `DocumentInfo` object and
	 * sent as a JSON message to the `documentQueue`.
	 * 
	 * @param file the file being uploaded
	 * @throws RabbitMQConnectionException if there is any issue connecting to or
	 *                                     sending the message to RabbitMQ
	 */
	public void sendFileToRabbitMQ(MultipartFile file) {
		try {

			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(Constants.DATE_TIME_PATTERN);
			String timestamp = LocalDateTime.now().format(formatter);
			String filename = timestamp.concat("_").concat(file.getOriginalFilename());

			DocumentInfo documentInfo = new DocumentInfo();
			documentInfo.setBucketName(bucketName);
			documentInfo.setFilename(filename);
			ObjectMapper mapper = new ObjectMapper();
			String messageJSON = mapper.writeValueAsString(documentInfo);

			// Send the message to RabbitMQ
			rabbitTemplate.convertAndSend(documentQueue, messageJSON);
			logger.info("File {} successfully sent to RabbitMQ.", filename);
		} catch (Exception e) {
			logger.error("Failed to send file to RabbitMQ: {}", e.getMessage());
			throw new RabbitMQConnectionException("Failed to send file to RabbitMQ", e);
		}
	}

	/**
	 * Uploads the file to MinIO (an S3-compatible object storage). The file is
	 * uploaded to a specified bucket with a unique file name generated by appending
	 * a timestamp to the original file name. The method uses the AWS SDK for S3 to
	 * upload the file to MinIO.
	 * 
	 * @param file the file being uploaded
	 * @return a success message if the upload is successful
	 * @throws MinioConnectionException if there is any issue during the file upload
	 *                                  to MinIO
	 */
	public String uploadToMinio(MultipartFile file) throws IOException {
		logger.info("Uploading the file to MinIO");
		try (InputStream inputStream = file.getInputStream()) {

			DateTimeFormatter formatter = DateTimeFormatter.ofPattern(Constants.DATE_TIME_PATTERN);
			String timestamp = LocalDateTime.now().format(formatter);
			String filename = timestamp.concat("_").concat(file.getOriginalFilename());

			PutObjectRequest putObjectRequest = PutObjectRequest.builder().bucket(bucketName).key(filename).build();

			s3Client.putObject(putObjectRequest,
					software.amazon.awssdk.core.sync.RequestBody.fromInputStream(inputStream, file.getSize()));
			return "File uploaded successfully!";
		} catch (S3Exception e) {
			logger.error("Exception Occurred while uploading file to Minio : {}", e.getMessage());
			throw new MinioConnectionException("Exception Occurred while uploading file to Minio : " + e.getMessage());
		}
	}

	/**
	 * This method listens to the "resultQueue" in RabbitMQ and processes the OCR
	 * results. It deserializes the message, updates the document's content in the
	 * database, and logs the success.
	 * 
	 * @param message The OCR result message containing file name and OCR content.
	 */
	@RabbitListener(queues = "resultQueue")
	public void processResult(@Payload String message) {
		try {
			ResultInfo resultInfo = deserializeMessage(message);
			String fileName = resultInfo.getFileName();
			String fileContent = resultInfo.getOcrResult();
			List<Document> docments = documentRepository.findByFileName(fileName);
			if (!CollectionUtils.isEmpty(docments)) {
				logger.info("Document fetched from DB with ID : {}", docments.get(0).getId());
				Document document = docments.get(0);
				document.setContent(fileContent);
				documentRepository.save(document);
				logger.info("Data saved successfully");
			}
		} catch (Exception e) {
			logger.error("Exception occurred while processing OCR result : {}", e.getMessage());
		}
	}

	/**
	 * This method deserializes the incoming RabbitMQ message into a ResultInfo
	 * object.
	 * 
	 * @param message The message to be deserialized.
	 * @return The deserialized ResultInfo object.
	 * @throws StreamReadException, DatabindException, IOException If an error
	 *                              occurs during deserialization.
	 */
	private ResultInfo deserializeMessage(String message) throws StreamReadException, DatabindException, IOException {
		ObjectMapper objectMapper = new ObjectMapper();
		return objectMapper.readValue(message, ResultInfo.class);
	}

	/**
	 * Retrieves a list of DocumentDTO objects based on the provided id and fileName.
	 * The method performs different query operations depending on the values of id and fileName:
	 * 
	 * - If id is 0 and fileName is provided, it fetches documents matching the fileName.
	 * - If id is not 0 and fileName is empty, it fetches a single document by id.
	 * - If both id and fileName are provided, it fetches documents matching both id and fileName.
	 * 
	 * If any documents are found, they are converted to DocumentDTOs using the MapStruct DocumentMapper.
	 * 
	 * @param id The id of the document(s) to be retrieved.
	 * @param fileName The file name of the document(s) to be retrieved.
	 * @return A list of DocumentDTO objects. If no documents are found, an empty list is returned.
	 */
	public List<DocumentDTO> getDocuments(long id, String fileName) {
		List<Document> documents = new ArrayList<>();
		List<DocumentDTO> documentDTOs = new ArrayList<>();
		try {
			if (id == 0 && StringUtils.isNotEmpty(fileName)) {
				documents = documentRepository.findByFileName(fileName);
			} else if (id != 0 && StringUtils.isEmpty(fileName)) {
				Document document = documentRepository.findById(id).get();
				documents.add(document);
			} else if (id != 0 && StringUtils.isNotEmpty(fileName)) {
				documents = documentRepository.findByFileNameAndId(fileName, id);
			}
		} catch (Exception e) {
			logger.error("Exception occurred while getting data : {}", e.getMessage());
		}

		if (!documents.isEmpty()) {
			documentDTOs = mapToDocumentDTO(documents, documentDTOs);
		}

		return documentDTOs;
	}


	/**
	 * Retrieves all documents from the repository and converts them to a list of DocumentDTO objects.
	 * The method fetches all documents from the repository using the `findAll()` method and then maps
	 * the list of Document entities to DocumentDTOs using the MapStruct DocumentMapper.
	 * 
	 * @return A list of DocumentDTO objects representing all documents in the repository.
	 *         If no documents are found, an empty list is returned.
	 */
	public List<DocumentDTO> getAllDocuments() {
		List<Document> documents = new ArrayList<>();
		List<DocumentDTO> documentDTOs = new ArrayList<>();
		try {
			documents = documentRepository.findAll();
		} catch (Exception e) {
			logger.error("Exception occurred while getting data : {}", e.getMessage());
		}
		if (!documents.isEmpty()) {
			documentDTOs = mapToDocumentDTO(documents, documentDTOs);
		}

		return documentDTOs;
	}
	

	/**
	 * Maps a list of Document entities to a list of DocumentDTO objects.
	 * For each Document in the input list, a corresponding DocumentDTO is created,
	 * its fields are populated with the values from the Document, and it is added to the output list.
	 *
	 * @param documents    The list of Document entities to be mapped.
	 * @param documentDTOs The list of DocumentDTOs to which the mapped DocumentDTOs will be added.
	 * @return The updated list of DocumentDTOs containing the mapped data from the documents.
	 */
	private List<DocumentDTO> mapToDocumentDTO(List<Document> documents, List<DocumentDTO> documentDTOs) {
		for (Document document : documents) {
			DocumentDTO documentDTO = new DocumentDTO();
			documentDTO.setId(document.getId());
			documentDTO.setFileName(document.getFileName());
			documentDTO.setFileSize(document.getFileSize());
			documentDTO.setUploadDate(document.getUploadDate());
			documentDTO.setContent(document.getContent());
			documentDTOs.add(documentDTO);
		}
		return documentDTOs;
	}
}
